
Kernel2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  000007cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000758  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000578  00800200  00800200  000007cc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000007cc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000007fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  0000083c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002621  00000000  00000000  00000974  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001254  00000000  00000000  00002f95  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b7c  00000000  00000000  000041e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000026c  00000000  00000000  00004d68  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009be  00000000  00000000  00004fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000008fb  00000000  00000000  00005992  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  0000628d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	81 c0       	rjmp	.+258    	; 0x108 <__bad_interrupt>
   6:	00 00       	nop
   8:	7f c0       	rjmp	.+254    	; 0x108 <__bad_interrupt>
   a:	00 00       	nop
   c:	7d c0       	rjmp	.+250    	; 0x108 <__bad_interrupt>
   e:	00 00       	nop
  10:	7b c0       	rjmp	.+246    	; 0x108 <__bad_interrupt>
  12:	00 00       	nop
  14:	79 c0       	rjmp	.+242    	; 0x108 <__bad_interrupt>
  16:	00 00       	nop
  18:	77 c0       	rjmp	.+238    	; 0x108 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	75 c0       	rjmp	.+234    	; 0x108 <__bad_interrupt>
  1e:	00 00       	nop
  20:	73 c0       	rjmp	.+230    	; 0x108 <__bad_interrupt>
  22:	00 00       	nop
  24:	71 c0       	rjmp	.+226    	; 0x108 <__bad_interrupt>
  26:	00 00       	nop
  28:	6f c0       	rjmp	.+222    	; 0x108 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	6d c0       	rjmp	.+218    	; 0x108 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6b c0       	rjmp	.+214    	; 0x108 <__bad_interrupt>
  32:	00 00       	nop
  34:	d1 c1       	rjmp	.+930    	; 0x3d8 <__vector_13>
  36:	00 00       	nop
  38:	21 c2       	rjmp	.+1090   	; 0x47c <__vector_14>
  3a:	00 00       	nop
  3c:	65 c0       	rjmp	.+202    	; 0x108 <__bad_interrupt>
  3e:	00 00       	nop
  40:	63 c0       	rjmp	.+198    	; 0x108 <__bad_interrupt>
  42:	00 00       	nop
  44:	61 c0       	rjmp	.+194    	; 0x108 <__bad_interrupt>
  46:	00 00       	nop
  48:	5f c0       	rjmp	.+190    	; 0x108 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	5d c0       	rjmp	.+186    	; 0x108 <__bad_interrupt>
  4e:	00 00       	nop
  50:	5b c0       	rjmp	.+182    	; 0x108 <__bad_interrupt>
  52:	00 00       	nop
  54:	59 c0       	rjmp	.+178    	; 0x108 <__bad_interrupt>
  56:	00 00       	nop
  58:	57 c0       	rjmp	.+174    	; 0x108 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	55 c0       	rjmp	.+170    	; 0x108 <__bad_interrupt>
  5e:	00 00       	nop
  60:	53 c0       	rjmp	.+166    	; 0x108 <__bad_interrupt>
  62:	00 00       	nop
  64:	51 c0       	rjmp	.+162    	; 0x108 <__bad_interrupt>
  66:	00 00       	nop
  68:	4f c0       	rjmp	.+158    	; 0x108 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	4d c0       	rjmp	.+154    	; 0x108 <__bad_interrupt>
  6e:	00 00       	nop
  70:	4b c0       	rjmp	.+150    	; 0x108 <__bad_interrupt>
  72:	00 00       	nop
  74:	49 c0       	rjmp	.+146    	; 0x108 <__bad_interrupt>
  76:	00 00       	nop
  78:	47 c0       	rjmp	.+142    	; 0x108 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	45 c0       	rjmp	.+138    	; 0x108 <__bad_interrupt>
  7e:	00 00       	nop
  80:	43 c0       	rjmp	.+134    	; 0x108 <__bad_interrupt>
  82:	00 00       	nop
  84:	41 c0       	rjmp	.+130    	; 0x108 <__bad_interrupt>
  86:	00 00       	nop
  88:	3f c0       	rjmp	.+126    	; 0x108 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	3d c0       	rjmp	.+122    	; 0x108 <__bad_interrupt>
  8e:	00 00       	nop
  90:	3b c0       	rjmp	.+118    	; 0x108 <__bad_interrupt>
  92:	00 00       	nop
  94:	39 c0       	rjmp	.+114    	; 0x108 <__bad_interrupt>
  96:	00 00       	nop
  98:	37 c0       	rjmp	.+110    	; 0x108 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	35 c0       	rjmp	.+106    	; 0x108 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	33 c0       	rjmp	.+102    	; 0x108 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	31 c0       	rjmp	.+98     	; 0x108 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	2f c0       	rjmp	.+94     	; 0x108 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	2d c0       	rjmp	.+90     	; 0x108 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	2b c0       	rjmp	.+86     	; 0x108 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	29 c0       	rjmp	.+82     	; 0x108 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	27 c0       	rjmp	.+78     	; 0x108 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	25 c0       	rjmp	.+74     	; 0x108 <__bad_interrupt>
  be:	00 00       	nop
  c0:	23 c0       	rjmp	.+70     	; 0x108 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	21 c0       	rjmp	.+66     	; 0x108 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	1f c0       	rjmp	.+62     	; 0x108 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	1d c0       	rjmp	.+58     	; 0x108 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	1b c0       	rjmp	.+54     	; 0x108 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	19 c0       	rjmp	.+50     	; 0x108 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	17 c0       	rjmp	.+46     	; 0x108 <__bad_interrupt>
  da:	00 00       	nop
  dc:	15 c0       	rjmp	.+42     	; 0x108 <__bad_interrupt>
  de:	00 00       	nop
  e0:	13 c0       	rjmp	.+38     	; 0x108 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_clear_bss>:
  f4:	27 e0       	ldi	r18, 0x07	; 7
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
  fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
  fe:	a8 37       	cpi	r26, 0x78	; 120
 100:	b2 07       	cpc	r27, r18
 102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
 104:	90 d2       	rcall	.+1312   	; 0x626 <main>
 106:	26 c3       	rjmp	.+1612   	; 0x754 <_exit>

00000108 <__bad_interrupt>:
 108:	7b cf       	rjmp	.-266    	; 0x0 <__vectors>

0000010a <stack_overflow>:
void stack_overflow()
{
	
}
void queue_overflow()
{
 10a:	08 95       	ret

0000010c <uninitialized_thread_error>:
	
}
void uninitialized_thread_error()
{
 10c:	08 95       	ret

0000010e <push_pthread>:
 *	func:	the function pointer to be pushed
 */
void push_pthread(uint8_t tid, PTHREAD func)
{
	// push low order byte
	*(kernel_data.thread_ctrl_tbl[tid].stack_ptr--) = (uint8_t) ((((uint16_t) func) & 0x00ff) >> 0);
 10e:	28 e0       	ldi	r18, 0x08	; 8
 110:	82 9f       	mul	r24, r18
 112:	c0 01       	movw	r24, r0
 114:	11 24       	eor	r1, r1
 116:	fc 01       	movw	r30, r24
 118:	e0 50       	subi	r30, 0x00	; 0
 11a:	fa 4f       	sbci	r31, 0xFA	; 250
 11c:	a0 81       	ld	r26, Z
 11e:	b1 81       	ldd	r27, Z+1	; 0x01
 120:	cd 01       	movw	r24, r26
 122:	01 97       	sbiw	r24, 0x01	; 1
 124:	91 83       	std	Z+1, r25	; 0x01
 126:	80 83       	st	Z, r24
 128:	6c 93       	st	X, r22
	// push middle order byte
	*(kernel_data.thread_ctrl_tbl[tid].stack_ptr--) = (uint8_t) ((((uint16_t) func) & 0xff00) >> 8);
 12a:	a0 81       	ld	r26, Z
 12c:	b1 81       	ldd	r27, Z+1	; 0x01
 12e:	cd 01       	movw	r24, r26
 130:	01 97       	sbiw	r24, 0x01	; 1
 132:	91 83       	std	Z+1, r25	; 0x01
 134:	80 83       	st	Z, r24
 136:	7c 93       	st	X, r23
	// push high order byte
	// because the ATmega2560 has a 17 bit address space for program memory and gcc uses 
	// 16 bit address space, the high order byte is always zero for a function pointer and 
	//trampoline tables are used for functions in high parts of program memory
	*(kernel_data.thread_ctrl_tbl[tid].stack_ptr--) = (uint8_t) (0x00);
 138:	a0 81       	ld	r26, Z
 13a:	b1 81       	ldd	r27, Z+1	; 0x01
 13c:	cd 01       	movw	r24, r26
 13e:	01 97       	sbiw	r24, 0x01	; 1
 140:	91 83       	std	Z+1, r25	; 0x01
 142:	80 83       	st	Z, r24
 144:	1c 92       	st	X, r1
 146:	08 95       	ret

00000148 <new>:
 *	entry_point:	function pointer that will be the thread's entry point. 
 *					Must be a no arg function. Any functions above 0xffff in program memory must make use of a trampoline table
 *	enabled:		boolean value. True if the thread should be enabled when this function exits
 */
void new(uint8_t tid, PTHREAD entry_point, bool enabled)
{
 148:	ff 92       	push	r15
 14a:	0f 93       	push	r16
 14c:	1f 93       	push	r17
 14e:	cf 93       	push	r28
 150:	df 93       	push	r29
 152:	c8 2f       	mov	r28, r24
 154:	f4 2e       	mov	r15, r20
	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 156:	df b7       	in	r29, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 158:	f8 94       	cli
	{
		kernel_data.thread_ctrl_tbl[tid].stack_ptr = kernel_data.thread_ctrl_tbl[tid].stack_base;
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	8c 01       	movw	r16, r24
 15e:	00 0f       	add	r16, r16
 160:	11 1f       	adc	r17, r17
 162:	00 0f       	add	r16, r16
 164:	11 1f       	adc	r17, r17
 166:	00 0f       	add	r16, r16
 168:	11 1f       	adc	r17, r17
 16a:	00 50       	subi	r16, 0x00	; 0
 16c:	1a 4f       	sbci	r17, 0xFA	; 250
 16e:	88 0f       	add	r24, r24
 170:	99 1f       	adc	r25, r25
 172:	88 0f       	add	r24, r24
 174:	99 1f       	adc	r25, r25
 176:	88 0f       	add	r24, r24
 178:	99 1f       	adc	r25, r25
 17a:	80 50       	subi	r24, 0x00	; 0
 17c:	9e 4f       	sbci	r25, 0xFE	; 254
 17e:	fc 01       	movw	r30, r24
 180:	ee 5f       	subi	r30, 0xFE	; 254
 182:	fb 4f       	sbci	r31, 0xFB	; 251
 184:	20 81       	ld	r18, Z
 186:	31 81       	ldd	r19, Z+1	; 0x01
 188:	f8 01       	movw	r30, r16
 18a:	31 83       	std	Z+1, r19	; 0x01
 18c:	20 83       	st	Z, r18
		kernel_data.thread_ctrl_tbl[tid].entry_pnt = entry_point;
 18e:	fc 01       	movw	r30, r24
 190:	ea 5f       	subi	r30, 0xFA	; 250
 192:	fb 4f       	sbci	r31, 0xFB	; 251
 194:	71 83       	std	Z+1, r23	; 0x01
 196:	60 83       	st	Z, r22
		push_pthread(tid, entry_point);
 198:	8c 2f       	mov	r24, r28
 19a:	b9 df       	rcall	.-142    	; 0x10e <push_pthread>
		kernel_data.thread_ctrl_tbl[tid].stack_ptr -= THREAD_STACK_CONTEXT_SZ;
 19c:	f8 01       	movw	r30, r16
 19e:	80 81       	ld	r24, Z
 1a0:	91 81       	ldd	r25, Z+1	; 0x01
 1a2:	9c 01       	movw	r18, r24
 1a4:	21 52       	subi	r18, 0x21	; 33
 1a6:	31 09       	sbc	r19, r1
 1a8:	31 83       	std	Z+1, r19	; 0x01
 1aa:	20 83       	st	Z, r18
		// for preemptive builds initialize the status register part of the context to have the interrupt enabled
		#		ifdef PREEMPTIVE
		*(kernel_data.thread_ctrl_tbl[tid].stack_ptr + 1) = 0x80;
 1ac:	fc 01       	movw	r30, r24
 1ae:	b0 97       	sbiw	r30, 0x20	; 32
 1b0:	20 e8       	ldi	r18, 0x80	; 128
 1b2:	20 83       	st	Z, r18
		#		endif /* PREEMPTIVE */
		
		if (enabled)
 1b4:	ff 20       	and	r15, r15
 1b6:	79 f0       	breq	.+30     	; 0x1d6 <new+0x8e>
		{
			kernel_data.schedule_ctrl.disable_status &= ~(1<<tid);
 1b8:	e0 e4       	ldi	r30, 0x40	; 64
 1ba:	f6 e0       	ldi	r31, 0x06	; 6
 1bc:	81 e0       	ldi	r24, 0x01	; 1
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	0c 2e       	mov	r0, r28
 1c2:	02 c0       	rjmp	.+4      	; 0x1c8 <new+0x80>
 1c4:	88 0f       	add	r24, r24
 1c6:	99 1f       	adc	r25, r25
 1c8:	0a 94       	dec	r0
 1ca:	e2 f7       	brpl	.-8      	; 0x1c4 <new+0x7c>
 1cc:	80 95       	com	r24
 1ce:	90 81       	ld	r25, Z
 1d0:	89 23       	and	r24, r25
 1d2:	80 83       	st	Z, r24
 1d4:	11 c0       	rjmp	.+34     	; 0x1f8 <new+0xb0>
		}
		else
		{
			kernel_data.schedule_ctrl.disable_status |= 1<<tid;
 1d6:	e0 e4       	ldi	r30, 0x40	; 64
 1d8:	f6 e0       	ldi	r31, 0x06	; 6
 1da:	81 e0       	ldi	r24, 0x01	; 1
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	0c 2e       	mov	r0, r28
 1e0:	02 c0       	rjmp	.+4      	; 0x1e6 <new+0x9e>
 1e2:	88 0f       	add	r24, r24
 1e4:	99 1f       	adc	r25, r25
 1e6:	0a 94       	dec	r0
 1e8:	e2 f7       	brpl	.-8      	; 0x1e2 <new+0x9a>
 1ea:	90 81       	ld	r25, Z
 1ec:	89 2b       	or	r24, r25
 1ee:	80 83       	st	Z, r24
		}
		
		if (kernel_data.schedule_ctrl.cur_thread_id == tid)
		{
			schedule();
 1f0:	03 c0       	rjmp	.+6      	; 0x1f8 <new+0xb0>
 1f2:	df d1       	rcall	.+958    	; 0x5b2 <schedule>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 1f4:	df bf       	out	0x3f, r29	; 63
		}
	}
}
 1f6:	05 c0       	rjmp	.+10     	; 0x202 <new+0xba>
		else
		{
			kernel_data.schedule_ctrl.disable_status |= 1<<tid;
		}
		
		if (kernel_data.schedule_ctrl.cur_thread_id == tid)
 1f8:	80 91 52 06 	lds	r24, 0x0652	; 0x800652 <_edata+0x452>
 1fc:	c8 17       	cp	r28, r24
 1fe:	c9 f3       	breq	.-14     	; 0x1f2 <new+0xaa>
 200:	f9 cf       	rjmp	.-14     	; 0x1f4 <new+0xac>
		{
			schedule();
		}
	}
}
 202:	df 91       	pop	r29
 204:	cf 91       	pop	r28
 206:	1f 91       	pop	r17
 208:	0f 91       	pop	r16
 20a:	ff 90       	pop	r15
 20c:	08 95       	ret

0000020e <copy_stack>:
 *	s1_base:	pointer to the base of the stack to be copied
 *	s1_ptr:		the stack pointer of the stack to be copied
 *	s2_ptr:		a pointer to the stack pointer of the stack to be copied to
 */
void copy_stack(uint8_t *s1_base, uint8_t *s1_ptr, volatile uint8_t **s2_ptr)
{
 20e:	cf 93       	push	r28
 210:	df 93       	push	r29
 212:	da 01       	movw	r26, r20
	while (s1_base > s1_ptr)
 214:	68 17       	cp	r22, r24
 216:	79 07       	cpc	r23, r25
 218:	a0 f4       	brcc	.+40     	; 0x242 <copy_stack+0x34>
 21a:	fc 01       	movw	r30, r24
 21c:	31 96       	adiw	r30, 0x01	; 1
 21e:	6f 5f       	subi	r22, 0xFF	; 255
 220:	7f 4f       	sbci	r23, 0xFF	; 255
	{
		**s2_ptr = *s1_base;
 222:	cd 91       	ld	r28, X+
 224:	dc 91       	ld	r29, X
 226:	11 97       	sbiw	r26, 0x01	; 1
 228:	82 91       	ld	r24, -Z
 22a:	88 83       	st	Y, r24
		--s1_base;
		--(*s2_ptr);
 22c:	2d 91       	ld	r18, X+
 22e:	3c 91       	ld	r19, X
 230:	11 97       	sbiw	r26, 0x01	; 1
 232:	21 50       	subi	r18, 0x01	; 1
 234:	31 09       	sbc	r19, r1
 236:	11 96       	adiw	r26, 0x01	; 1
 238:	3c 93       	st	X, r19
 23a:	2e 93       	st	-X, r18
 *	s1_ptr:		the stack pointer of the stack to be copied
 *	s2_ptr:		a pointer to the stack pointer of the stack to be copied to
 */
void copy_stack(uint8_t *s1_base, uint8_t *s1_ptr, volatile uint8_t **s2_ptr)
{
	while (s1_base > s1_ptr)
 23c:	e6 17       	cp	r30, r22
 23e:	f7 07       	cpc	r31, r23
 240:	81 f7       	brne	.-32     	; 0x222 <copy_stack+0x14>
	{
		**s2_ptr = *s1_base;
		--s1_base;
		--(*s2_ptr);
	}
 242:	df 91       	pop	r29
 244:	cf 91       	pop	r28
 246:	08 95       	ret

00000248 <init>:

/*
 *	Initialized the kernel and copies the stack to thread0's stack and returns executing in thread0
 */
void init()
{
 248:	cf 93       	push	r28
 24a:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 24c:	f8 94       	cli
	// initialize kernel data and enable interrupts on exit
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		// initialize the thread control structure and stack canary for each thread
		THREAD_INIT(THREAD0, kernel_data.stacks.stack0, T0_STACKSZ);
 24e:	e0 e0       	ldi	r30, 0x00	; 0
 250:	f2 e0       	ldi	r31, 0x02	; 2
 252:	c0 e0       	ldi	r28, 0x00	; 0
 254:	d6 e0       	ldi	r29, 0x06	; 6
 256:	8f e7       	ldi	r24, 0x7F	; 127
 258:	92 e0       	ldi	r25, 0x02	; 2
 25a:	99 83       	std	Y+1, r25	; 0x01
 25c:	88 83       	st	Y, r24
 25e:	90 93 03 06 	sts	0x0603, r25	; 0x800603 <_edata+0x403>
 262:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <_edata+0x402>
 266:	f0 93 05 06 	sts	0x0605, r31	; 0x800605 <_edata+0x405>
 26a:	e0 93 04 06 	sts	0x0604, r30	; 0x800604 <_edata+0x404>
 26e:	2a ea       	ldi	r18, 0xAA	; 170
 270:	20 83       	st	Z, r18
 272:	86 e8       	ldi	r24, 0x86	; 134
 274:	90 e0       	ldi	r25, 0x00	; 0
 276:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <_edata+0x407>
 27a:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <_edata+0x406>
		THREAD_INIT(THREAD1, kernel_data.stacks.stack1, T1_STACKSZ);
 27e:	4f ef       	ldi	r20, 0xFF	; 255
 280:	52 e0       	ldi	r21, 0x02	; 2
 282:	50 93 09 06 	sts	0x0609, r21	; 0x800609 <_edata+0x409>
 286:	40 93 08 06 	sts	0x0608, r20	; 0x800608 <_edata+0x408>
 28a:	50 93 0b 06 	sts	0x060B, r21	; 0x80060b <_edata+0x40b>
 28e:	40 93 0a 06 	sts	0x060A, r20	; 0x80060a <_edata+0x40a>
 292:	e0 e8       	ldi	r30, 0x80	; 128
 294:	f2 e0       	ldi	r31, 0x02	; 2
 296:	f0 93 0d 06 	sts	0x060D, r31	; 0x80060d <_edata+0x40d>
 29a:	e0 93 0c 06 	sts	0x060C, r30	; 0x80060c <_edata+0x40c>
 29e:	20 83       	st	Z, r18
 2a0:	90 93 0f 06 	sts	0x060F, r25	; 0x80060f <_edata+0x40f>
 2a4:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <_edata+0x40e>
		THREAD_INIT(THREAD2, kernel_data.stacks.stack2, T2_STACKSZ);
 2a8:	4f e7       	ldi	r20, 0x7F	; 127
 2aa:	53 e0       	ldi	r21, 0x03	; 3
 2ac:	50 93 11 06 	sts	0x0611, r21	; 0x800611 <_edata+0x411>
 2b0:	40 93 10 06 	sts	0x0610, r20	; 0x800610 <_edata+0x410>
 2b4:	50 93 13 06 	sts	0x0613, r21	; 0x800613 <_edata+0x413>
 2b8:	40 93 12 06 	sts	0x0612, r20	; 0x800612 <_edata+0x412>
 2bc:	e0 e0       	ldi	r30, 0x00	; 0
 2be:	f3 e0       	ldi	r31, 0x03	; 3
 2c0:	f0 93 15 06 	sts	0x0615, r31	; 0x800615 <_edata+0x415>
 2c4:	e0 93 14 06 	sts	0x0614, r30	; 0x800614 <_edata+0x414>
 2c8:	20 83       	st	Z, r18
 2ca:	90 93 17 06 	sts	0x0617, r25	; 0x800617 <_edata+0x417>
 2ce:	80 93 16 06 	sts	0x0616, r24	; 0x800616 <_edata+0x416>
		THREAD_INIT(THREAD3, kernel_data.stacks.stack3, T3_STACKSZ);
 2d2:	4f ef       	ldi	r20, 0xFF	; 255
 2d4:	53 e0       	ldi	r21, 0x03	; 3
 2d6:	50 93 19 06 	sts	0x0619, r21	; 0x800619 <_edata+0x419>
 2da:	40 93 18 06 	sts	0x0618, r20	; 0x800618 <_edata+0x418>
 2de:	50 93 1b 06 	sts	0x061B, r21	; 0x80061b <_edata+0x41b>
 2e2:	40 93 1a 06 	sts	0x061A, r20	; 0x80061a <_edata+0x41a>
 2e6:	e0 e8       	ldi	r30, 0x80	; 128
 2e8:	f3 e0       	ldi	r31, 0x03	; 3
 2ea:	f0 93 1d 06 	sts	0x061D, r31	; 0x80061d <_edata+0x41d>
 2ee:	e0 93 1c 06 	sts	0x061C, r30	; 0x80061c <_edata+0x41c>
 2f2:	20 83       	st	Z, r18
 2f4:	90 93 1f 06 	sts	0x061F, r25	; 0x80061f <_edata+0x41f>
 2f8:	80 93 1e 06 	sts	0x061E, r24	; 0x80061e <_edata+0x41e>
		THREAD_INIT(THREAD4, kernel_data.stacks.stack4, T4_STACKSZ);
 2fc:	4f e7       	ldi	r20, 0x7F	; 127
 2fe:	54 e0       	ldi	r21, 0x04	; 4
 300:	50 93 21 06 	sts	0x0621, r21	; 0x800621 <_edata+0x421>
 304:	40 93 20 06 	sts	0x0620, r20	; 0x800620 <_edata+0x420>
 308:	50 93 23 06 	sts	0x0623, r21	; 0x800623 <_edata+0x423>
 30c:	40 93 22 06 	sts	0x0622, r20	; 0x800622 <_edata+0x422>
 310:	e0 e0       	ldi	r30, 0x00	; 0
 312:	f4 e0       	ldi	r31, 0x04	; 4
 314:	f0 93 25 06 	sts	0x0625, r31	; 0x800625 <_edata+0x425>
 318:	e0 93 24 06 	sts	0x0624, r30	; 0x800624 <_edata+0x424>
 31c:	20 83       	st	Z, r18
 31e:	90 93 27 06 	sts	0x0627, r25	; 0x800627 <_edata+0x427>
 322:	80 93 26 06 	sts	0x0626, r24	; 0x800626 <_edata+0x426>
		THREAD_INIT(THREAD5, kernel_data.stacks.stack5, T5_STACKSZ);
 326:	4f ef       	ldi	r20, 0xFF	; 255
 328:	54 e0       	ldi	r21, 0x04	; 4
 32a:	50 93 29 06 	sts	0x0629, r21	; 0x800629 <_edata+0x429>
 32e:	40 93 28 06 	sts	0x0628, r20	; 0x800628 <_edata+0x428>
 332:	50 93 2b 06 	sts	0x062B, r21	; 0x80062b <_edata+0x42b>
 336:	40 93 2a 06 	sts	0x062A, r20	; 0x80062a <_edata+0x42a>
 33a:	e0 e8       	ldi	r30, 0x80	; 128
 33c:	f4 e0       	ldi	r31, 0x04	; 4
 33e:	f0 93 2d 06 	sts	0x062D, r31	; 0x80062d <_edata+0x42d>
 342:	e0 93 2c 06 	sts	0x062C, r30	; 0x80062c <_edata+0x42c>
 346:	20 83       	st	Z, r18
 348:	90 93 2f 06 	sts	0x062F, r25	; 0x80062f <_edata+0x42f>
 34c:	80 93 2e 06 	sts	0x062E, r24	; 0x80062e <_edata+0x42e>
		THREAD_INIT(THREAD6, kernel_data.stacks.stack6, T6_STACKSZ);
 350:	4f e7       	ldi	r20, 0x7F	; 127
 352:	55 e0       	ldi	r21, 0x05	; 5
 354:	50 93 31 06 	sts	0x0631, r21	; 0x800631 <_edata+0x431>
 358:	40 93 30 06 	sts	0x0630, r20	; 0x800630 <_edata+0x430>
 35c:	50 93 33 06 	sts	0x0633, r21	; 0x800633 <_edata+0x433>
 360:	40 93 32 06 	sts	0x0632, r20	; 0x800632 <_edata+0x432>
 364:	e0 e0       	ldi	r30, 0x00	; 0
 366:	f5 e0       	ldi	r31, 0x05	; 5
 368:	f0 93 35 06 	sts	0x0635, r31	; 0x800635 <_edata+0x435>
 36c:	e0 93 34 06 	sts	0x0634, r30	; 0x800634 <_edata+0x434>
 370:	20 83       	st	Z, r18
 372:	90 93 37 06 	sts	0x0637, r25	; 0x800637 <_edata+0x437>
 376:	80 93 36 06 	sts	0x0636, r24	; 0x800636 <_edata+0x436>
		THREAD_INIT(THREAD7, kernel_data.stacks.stack7, T7_STACKSZ);
 37a:	4f ef       	ldi	r20, 0xFF	; 255
 37c:	55 e0       	ldi	r21, 0x05	; 5
 37e:	50 93 39 06 	sts	0x0639, r21	; 0x800639 <_edata+0x439>
 382:	40 93 38 06 	sts	0x0638, r20	; 0x800638 <_edata+0x438>
 386:	50 93 3b 06 	sts	0x063B, r21	; 0x80063b <_edata+0x43b>
 38a:	40 93 3a 06 	sts	0x063A, r20	; 0x80063a <_edata+0x43a>
 38e:	e0 e8       	ldi	r30, 0x80	; 128
 390:	f5 e0       	ldi	r31, 0x05	; 5
 392:	f0 93 3d 06 	sts	0x063D, r31	; 0x80063d <_edata+0x43d>
 396:	e0 93 3c 06 	sts	0x063C, r30	; 0x80063c <_edata+0x43c>
 39a:	20 83       	st	Z, r18
 39c:	90 93 3f 06 	sts	0x063F, r25	; 0x80063f <_edata+0x43f>
 3a0:	80 93 3e 06 	sts	0x063E, r24	; 0x80063e <_edata+0x43e>
		
		// copy the stack to the thread 0 stack and set the stack pointer register to thread0's stack pointer
		copy_stack(GCC_STACK_BASE, *(uint8_t **)STACK_POINTER, &(kernel_data.thread_ctrl_tbl[THREAD0].stack_ptr));
 3a4:	6d b7       	in	r22, 0x3d	; 61
 3a6:	7e b7       	in	r23, 0x3e	; 62
 3a8:	ae 01       	movw	r20, r28
 3aa:	8f ef       	ldi	r24, 0xFF	; 255
 3ac:	91 e2       	ldi	r25, 0x21	; 33
 3ae:	2f df       	rcall	.-418    	; 0x20e <copy_stack>
		*STACK_POINTER = kernel_data.thread_ctrl_tbl[THREAD0].stack_ptr;
 3b0:	88 81       	ld	r24, Y
 3b2:	99 81       	ldd	r25, Y+1	; 0x01
 3b4:	9e bf       	out	0x3e, r25	; 62
 3b6:	8d bf       	out	0x3d, r24	; 61
		
		// initialize the disable status to disable all but thread  0
		kernel_data.schedule_ctrl.disable_status = THREAD1_MSK | THREAD2_MSK | THREAD3_MSK
 3b8:	8e ef       	ldi	r24, 0xFE	; 254
 3ba:	80 93 40 06 	sts	0x0640, r24	; 0x800640 <_edata+0x440>
		| THREAD4_MSK | THREAD5_MSK | THREAD6_MSK | THREAD7_MSK;
		// initialize the delay_status so no threads are delayed
		kernel_data.schedule_ctrl.delay_status = 0x00;
 3be:	10 92 41 06 	sts	0x0641, r1	; 0x800641 <_edata+0x441>
		// initialize the current thread and current thread mask to thread0
		kernel_data.schedule_ctrl.cur_thread_id = THREAD0;
 3c2:	10 92 52 06 	sts	0x0652, r1	; 0x800652 <_edata+0x452>
		kernel_data.schedule_ctrl.cur_thread_msk = THREAD0_MSK;
 3c6:	81 e0       	ldi	r24, 0x01	; 1
 3c8:	80 93 53 06 	sts	0x0653, r24	; 0x800653 <_edata+0x453>
		
		// initialize other functionality
		
		init_system_timer();
		#	ifdef SERIAL
		init_serial();
 3cc:	58 d0       	rcall	.+176    	; 0x47e <init_system_timer>
 3ce:	57 d1       	rcall	.+686    	; 0x67e <init_serial>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
 3d0:	78 94       	sei
		#	endif /* SERIAL */
	}
}
 3d2:	df 91       	pop	r29
 3d4:	cf 91       	pop	r28
 3d6:	08 95       	ret

000003d8 <__vector_13>:
{
	
}

void unlock()
{
 3d8:	1f 92       	push	r1
 3da:	0f 92       	push	r0
 3dc:	0f b6       	in	r0, 0x3f	; 63
 3de:	0f 92       	push	r0
 3e0:	11 24       	eor	r1, r1
 3e2:	0b b6       	in	r0, 0x3b	; 59
 3e4:	0f 92       	push	r0
 3e6:	2f 93       	push	r18
 3e8:	3f 93       	push	r19
 3ea:	4f 93       	push	r20
 3ec:	6f 93       	push	r22
 3ee:	7f 93       	push	r23
 3f0:	8f 93       	push	r24
 3f2:	9f 93       	push	r25
 3f4:	af 93       	push	r26
 3f6:	bf 93       	push	r27
 3f8:	ef 93       	push	r30
 3fa:	ff 93       	push	r31
 3fc:	e3 eb       	ldi	r30, 0xB3	; 179
 3fe:	f0 e0       	ldi	r31, 0x00	; 0
 400:	80 81       	ld	r24, Z
 402:	87 50       	subi	r24, 0x07	; 7
 404:	80 83       	st	Z, r24
 406:	40 91 41 06 	lds	r20, 0x0641	; 0x800641 <_edata+0x441>
 40a:	e2 e4       	ldi	r30, 0x42	; 66
 40c:	f6 e0       	ldi	r31, 0x06	; 6
 40e:	62 e5       	ldi	r22, 0x52	; 82
 410:	76 e0       	ldi	r23, 0x06	; 6
 412:	81 e0       	ldi	r24, 0x01	; 1
 414:	94 2f       	mov	r25, r20
 416:	98 23       	and	r25, r24
 418:	59 f0       	breq	.+22     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
 41a:	20 81       	ld	r18, Z
 41c:	31 81       	ldd	r19, Z+1	; 0x01
 41e:	21 50       	subi	r18, 0x01	; 1
 420:	31 09       	sbc	r19, r1
 422:	31 83       	std	Z+1, r19	; 0x01
 424:	20 83       	st	Z, r18
 426:	23 2b       	or	r18, r19
 428:	19 f4       	brne	.+6      	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
 42a:	98 2f       	mov	r25, r24
 42c:	90 95       	com	r25
 42e:	49 23       	and	r20, r25
 430:	88 0f       	add	r24, r24
 432:	32 96       	adiw	r30, 0x02	; 2
 434:	e6 17       	cp	r30, r22
 436:	f7 07       	cpc	r31, r23
 438:	69 f7       	brne	.-38     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
 43a:	40 93 41 06 	sts	0x0641, r20	; 0x800641 <_edata+0x441>
 43e:	e4 e5       	ldi	r30, 0x54	; 84
 440:	f6 e0       	ldi	r31, 0x06	; 6
 442:	80 81       	ld	r24, Z
 444:	91 81       	ldd	r25, Z+1	; 0x01
 446:	a2 81       	ldd	r26, Z+2	; 0x02
 448:	b3 81       	ldd	r27, Z+3	; 0x03
 44a:	01 96       	adiw	r24, 0x01	; 1
 44c:	a1 1d       	adc	r26, r1
 44e:	b1 1d       	adc	r27, r1
 450:	80 83       	st	Z, r24
 452:	91 83       	std	Z+1, r25	; 0x01
 454:	a2 83       	std	Z+2, r26	; 0x02
 456:	b3 83       	std	Z+3, r27	; 0x03
 458:	ff 91       	pop	r31
 45a:	ef 91       	pop	r30
 45c:	bf 91       	pop	r27
 45e:	af 91       	pop	r26
 460:	9f 91       	pop	r25
 462:	8f 91       	pop	r24
 464:	7f 91       	pop	r23
 466:	6f 91       	pop	r22
 468:	4f 91       	pop	r20
 46a:	3f 91       	pop	r19
 46c:	2f 91       	pop	r18
 46e:	0f 90       	pop	r0
 470:	0b be       	out	0x3b, r0	; 59
 472:	0f 90       	pop	r0
 474:	0f be       	out	0x3f, r0	; 63
 476:	0f 90       	pop	r0
 478:	1f 90       	pop	r1
 47a:	18 95       	reti

0000047c <__vector_14>:
 47c:	2c c0       	rjmp	.+88     	; 0x4d6 <save_context>

0000047e <init_system_timer>:
 47e:	10 92 b0 00 	sts	0x00B0, r1	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7c00b0>
 482:	84 e0       	ldi	r24, 0x04	; 4
 484:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7c00b1>
 488:	89 ef       	ldi	r24, 0xF9	; 249
 48a:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7c00b3>
 48e:	8f e8       	ldi	r24, 0x8F	; 143
 490:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7c00b4>
 494:	86 e0       	ldi	r24, 0x06	; 6
 496:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7c0070>
 49a:	10 92 54 06 	sts	0x0654, r1	; 0x800654 <_edata+0x454>
 49e:	10 92 55 06 	sts	0x0655, r1	; 0x800655 <_edata+0x455>
 4a2:	10 92 56 06 	sts	0x0656, r1	; 0x800656 <_edata+0x456>
 4a6:	10 92 57 06 	sts	0x0657, r1	; 0x800657 <_edata+0x457>
 4aa:	08 95       	ret

000004ac <delay>:
 4ac:	9c 01       	movw	r18, r24
 4ae:	9f b7       	in	r25, 0x3f	; 63
 4b0:	f8 94       	cli
 4b2:	e0 91 52 06 	lds	r30, 0x0652	; 0x800652 <_edata+0x452>
 4b6:	f0 e0       	ldi	r31, 0x00	; 0
 4b8:	ee 0f       	add	r30, r30
 4ba:	ff 1f       	adc	r31, r31
 4bc:	ee 5b       	subi	r30, 0xBE	; 190
 4be:	f9 4f       	sbci	r31, 0xF9	; 249
 4c0:	31 83       	std	Z+1, r19	; 0x01
 4c2:	20 83       	st	Z, r18
 4c4:	e1 e4       	ldi	r30, 0x41	; 65
 4c6:	f6 e0       	ldi	r31, 0x06	; 6
 4c8:	20 81       	ld	r18, Z
 4ca:	80 91 53 06 	lds	r24, 0x0653	; 0x800653 <_edata+0x453>
 4ce:	82 2b       	or	r24, r18
 4d0:	80 83       	st	Z, r24
 4d2:	9f bf       	out	0x3f, r25	; 63
 4d4:	00 c0       	rjmp	.+0      	; 0x4d6 <save_context>

000004d6 <save_context>:
****************************************************************************/

void __attribute__ ((naked)) save_context()
{	
	// save general purpose registers to stack
	asm volatile ("push r0\n\
 4d6:	0f 92       	push	r0
 4d8:	1f 92       	push	r1
 4da:	2f 92       	push	r2
 4dc:	3f 92       	push	r3
 4de:	4f 92       	push	r4
 4e0:	5f 92       	push	r5
 4e2:	6f 92       	push	r6
 4e4:	7f 92       	push	r7
 4e6:	8f 92       	push	r8
 4e8:	9f 92       	push	r9
 4ea:	af 92       	push	r10
 4ec:	bf 92       	push	r11
 4ee:	cf 92       	push	r12
 4f0:	df 92       	push	r13
 4f2:	ef 92       	push	r14
 4f4:	ff 92       	push	r15
 4f6:	0f 93       	push	r16
 4f8:	1f 93       	push	r17
 4fa:	2f 93       	push	r18
 4fc:	3f 93       	push	r19
 4fe:	4f 93       	push	r20
 500:	5f 93       	push	r21
 502:	6f 93       	push	r22
 504:	7f 93       	push	r23
 506:	8f 93       	push	r24
 508:	9f 93       	push	r25
 50a:	af 93       	push	r26
 50c:	bf 93       	push	r27
 50e:	cf 93       	push	r28
 510:	df 93       	push	r29
 512:	ef 93       	push	r30
 514:	ff 93       	push	r31
				   push r29\n\
				   push r30\n\
				   push r31");
	
	// save status register
	asm volatile ("in r0, 0x3f\n\
 516:	0f b6       	in	r0, 0x3f	; 63
 518:	0f 92       	push	r0
				   push r0");
	
	//	save stack pointer		   
	kernel_data.thread_ctrl_tbl[kernel_data.schedule_ctrl.cur_thread_id].stack_ptr = *STACK_POINTER;
 51a:	8d b7       	in	r24, 0x3d	; 61
 51c:	9e b7       	in	r25, 0x3e	; 62
 51e:	e0 91 52 06 	lds	r30, 0x0652	; 0x800652 <_edata+0x452>
 522:	f0 e0       	ldi	r31, 0x00	; 0
 524:	ee 0f       	add	r30, r30
 526:	ff 1f       	adc	r31, r31
 528:	ee 0f       	add	r30, r30
 52a:	ff 1f       	adc	r31, r31
 52c:	ee 0f       	add	r30, r30
 52e:	ff 1f       	adc	r31, r31
 530:	e0 50       	subi	r30, 0x00	; 0
 532:	fa 4f       	sbci	r31, 0xFA	; 250
 534:	91 83       	std	Z+1, r25	; 0x01
 536:	80 83       	st	Z, r24
	
	// jump to the scheduler
	asm volatile ("rjmp schedule");
 538:	3c c0       	rjmp	.+120    	; 0x5b2 <schedule>

0000053a <restore_context>:
}

void __attribute__ ((naked)) restore_context()
{
	// increment OCR2B to match on at the end of the next time slice
	OCR2B += (F_CPU / USEC_PRE_TIME_SLIZE) / TIMER2_PRESCALLER - 1;
 53a:	e4 eb       	ldi	r30, 0xB4	; 180
 53c:	f0 e0       	ldi	r31, 0x00	; 0
 53e:	80 81       	ld	r24, Z
 540:	81 57       	subi	r24, 0x71	; 113
 542:	80 83       	st	Z, r24
	
	// enable the TIMER2_COMPB interrupt to allow for rescheduling
	TIMSK2 |= 0b1<<OCIE2B;
 544:	e0 e7       	ldi	r30, 0x70	; 112
 546:	f0 e0       	ldi	r31, 0x00	; 0
 548:	80 81       	ld	r24, Z
 54a:	84 60       	ori	r24, 0x04	; 4
 54c:	80 83       	st	Z, r24
	
	// restore stack pointer
	*STACK_POINTER = kernel_data.thread_ctrl_tbl[kernel_data.schedule_ctrl.cur_thread_id].stack_ptr;
 54e:	e0 91 52 06 	lds	r30, 0x0652	; 0x800652 <_edata+0x452>
 552:	f0 e0       	ldi	r31, 0x00	; 0
 554:	ee 0f       	add	r30, r30
 556:	ff 1f       	adc	r31, r31
 558:	ee 0f       	add	r30, r30
 55a:	ff 1f       	adc	r31, r31
 55c:	ee 0f       	add	r30, r30
 55e:	ff 1f       	adc	r31, r31
 560:	e0 50       	subi	r30, 0x00	; 0
 562:	fa 4f       	sbci	r31, 0xFA	; 250
 564:	80 81       	ld	r24, Z
 566:	91 81       	ldd	r25, Z+1	; 0x01
 568:	9e bf       	out	0x3e, r25	; 62
 56a:	8d bf       	out	0x3d, r24	; 61
	
	// restore status register
	asm volatile ("pop r0\n\
 56c:	0f 90       	pop	r0
 56e:	0f be       	out	0x3f, r0	; 63
				   out 0x3f, r0");
	
	// restore general purpose registers
	asm volatile ("pop r31\n\
 570:	ff 91       	pop	r31
 572:	ef 91       	pop	r30
 574:	df 91       	pop	r29
 576:	cf 91       	pop	r28
 578:	bf 91       	pop	r27
 57a:	af 91       	pop	r26
 57c:	9f 91       	pop	r25
 57e:	8f 91       	pop	r24
 580:	7f 91       	pop	r23
 582:	6f 91       	pop	r22
 584:	5f 91       	pop	r21
 586:	4f 91       	pop	r20
 588:	3f 91       	pop	r19
 58a:	2f 91       	pop	r18
 58c:	1f 91       	pop	r17
 58e:	0f 91       	pop	r16
 590:	ff 90       	pop	r15
 592:	ef 90       	pop	r14
 594:	df 90       	pop	r13
 596:	cf 90       	pop	r12
 598:	bf 90       	pop	r11
 59a:	af 90       	pop	r10
 59c:	9f 90       	pop	r9
 59e:	8f 90       	pop	r8
 5a0:	7f 90       	pop	r7
 5a2:	6f 90       	pop	r6
 5a4:	5f 90       	pop	r5
 5a6:	4f 90       	pop	r4
 5a8:	3f 90       	pop	r3
 5aa:	2f 90       	pop	r2
 5ac:	1f 90       	pop	r1
 5ae:	0f 90       	pop	r0
				   pop r2\n\
				   pop r1\n\
				   pop r0");
	
	// the next address on the stack should be the address of the next instruction tobe executed in the current thread
	asm volatile ("reti");
 5b0:	18 95       	reti

000005b2 <schedule>:
}

void __attribute__ ((naked)) schedule()
{
	// disable TIMER2_COMPB interrupt to prevent the scheduler from being invoked during sleep
	TIMSK2 &= ~(0b1<<OCIE2B);
 5b2:	e0 e7       	ldi	r30, 0x70	; 112
 5b4:	f0 e0       	ldi	r31, 0x00	; 0
 5b6:	80 81       	ld	r24, Z
 5b8:	8b 7f       	andi	r24, 0xFB	; 251
 5ba:	80 83       	st	Z, r24
	
	// verify canary
	if (*(kernel_data.thread_ctrl_tbl[kernel_data.schedule_ctrl.cur_thread_id].canary_ptr) != CANARY)
 5bc:	e0 91 52 06 	lds	r30, 0x0652	; 0x800652 <_edata+0x452>
 5c0:	f0 e0       	ldi	r31, 0x00	; 0
 5c2:	ee 0f       	add	r30, r30
 5c4:	ff 1f       	adc	r31, r31
 5c6:	ee 0f       	add	r30, r30
 5c8:	ff 1f       	adc	r31, r31
 5ca:	ee 0f       	add	r30, r30
 5cc:	ff 1f       	adc	r31, r31
 5ce:	ec 5f       	subi	r30, 0xFC	; 252
 5d0:	f9 4f       	sbci	r31, 0xF9	; 249
 5d2:	01 90       	ld	r0, Z+
 5d4:	f0 81       	ld	r31, Z
 5d6:	e0 2d       	mov	r30, r0
 5d8:	80 81       	ld	r24, Z
 5da:	8a 3a       	cpi	r24, 0xAA	; 170
 5dc:	09 f0       	breq	.+2      	; 0x5e0 <schedule+0x2e>
	{
		stack_overflow();
 5de:	95 dd       	rcall	.-1238   	; 0x10a <stack_overflow>
	
	// compute ready status and sleep if no threads are ready
	uint8_t ready_status;
	do
	{
		ready_status = kernel_data.schedule_ctrl.disable_status;
 5e0:	a0 e4       	ldi	r26, 0x40	; 64
 5e2:	b6 e0       	ldi	r27, 0x06	; 6
		ready_status |= kernel_data.schedule_ctrl.delay_status;
 5e4:	e1 e4       	ldi	r30, 0x41	; 65
 5e6:	f6 e0       	ldi	r31, 0x06	; 6
		ready_status = ~ready_status;
		if (!ready_status)
		{
			// enter the extended standby sleep mode if no threads are ready
			SMCR = SLEEP_MODE_EXT_STANDBY | (0b1 << SE);
 5e8:	2f e0       	ldi	r18, 0x0F	; 15
	
	// compute ready status and sleep if no threads are ready
	uint8_t ready_status;
	do
	{
		ready_status = kernel_data.schedule_ctrl.disable_status;
 5ea:	9c 91       	ld	r25, X
		ready_status |= kernel_data.schedule_ctrl.delay_status;
 5ec:	80 81       	ld	r24, Z
 5ee:	89 2b       	or	r24, r25
		ready_status = ~ready_status;
 5f0:	80 95       	com	r24
		if (!ready_status)
 5f2:	29 f4       	brne	.+10     	; 0x5fe <schedule+0x4c>
		{
			// enter the extended standby sleep mode if no threads are ready
			SMCR = SLEEP_MODE_EXT_STANDBY | (0b1 << SE);
 5f4:	23 bf       	out	0x33, r18	; 51
			sei();
 5f6:	78 94       	sei
			asm volatile ("sleep");
 5f8:	88 95       	sleep
			cli();
 5fa:	f8 94       	cli
 5fc:	f6 cf       	rjmp	.-20     	; 0x5ea <schedule+0x38>
	} while (!ready_status);
	
	// schedule the next thread
	do
	{
		kernel_data.schedule_ctrl.cur_thread_id = (kernel_data.schedule_ctrl.cur_thread_id + 1) & 0x07;
 5fe:	a2 e5       	ldi	r26, 0x52	; 82
 600:	b6 e0       	ldi	r27, 0x06	; 6
		asm volatile ("lsl %1\n\
					   clr r1\n\
					   adc %1, r1"
					   : "=r" (kernel_data.schedule_ctrl.cur_thread_msk)
					   : "r" (kernel_data.schedule_ctrl.cur_thread_msk));
 602:	e3 e5       	ldi	r30, 0x53	; 83
 604:	f6 e0       	ldi	r31, 0x06	; 6
	} while (!ready_status);
	
	// schedule the next thread
	do
	{
		kernel_data.schedule_ctrl.cur_thread_id = (kernel_data.schedule_ctrl.cur_thread_id + 1) & 0x07;
 606:	9c 91       	ld	r25, X
 608:	9f 5f       	subi	r25, 0xFF	; 255
 60a:	97 70       	andi	r25, 0x07	; 7
 60c:	9c 93       	st	X, r25
		asm volatile ("lsl %1\n\
 60e:	90 81       	ld	r25, Z
 610:	99 0f       	add	r25, r25
 612:	11 24       	eor	r1, r1
 614:	91 1d       	adc	r25, r1
 616:	90 83       	st	Z, r25
					   clr r1\n\
					   adc %1, r1"
					   : "=r" (kernel_data.schedule_ctrl.cur_thread_msk)
					   : "r" (kernel_data.schedule_ctrl.cur_thread_msk));
	} while (!(kernel_data.schedule_ctrl.cur_thread_msk & ready_status));
 618:	98 23       	and	r25, r24
 61a:	a9 f3       	breq	.-22     	; 0x606 <schedule+0x54>
	
	// jump to restore the new current thread's context
	asm volatile ("rjmp restore_context");
 61c:	8e cf       	rjmp	.-228    	; 0x53a <restore_context>

0000061e <t0>:
		delay(5);
	}
}

void t2()
{
 61e:	82 e3       	ldi	r24, 0x32	; 50
 620:	90 e0       	ldi	r25, 0x00	; 0
 622:	44 df       	rcall	.-376    	; 0x4ac <delay>
 624:	fc cf       	rjmp	.-8      	; 0x61e <t0>

00000626 <main>:
	}
}

int main(void)
{
	init();
 626:	10 de       	rcall	.-992    	; 0x248 <init>
	new(7, t0, true);
 628:	41 e0       	ldi	r20, 0x01	; 1
 62a:	6f e0       	ldi	r22, 0x0F	; 15
 62c:	73 e0       	ldi	r23, 0x03	; 3
 62e:	87 e0       	ldi	r24, 0x07	; 7
 630:	8b dd       	rcall	.-1258   	; 0x148 <new>
	new(6, t0, true);
 632:	41 e0       	ldi	r20, 0x01	; 1
 634:	6f e0       	ldi	r22, 0x0F	; 15
 636:	73 e0       	ldi	r23, 0x03	; 3
 638:	86 e0       	ldi	r24, 0x06	; 6
 63a:	86 dd       	rcall	.-1268   	; 0x148 <new>
	new(5, t0, true);
 63c:	41 e0       	ldi	r20, 0x01	; 1
 63e:	6f e0       	ldi	r22, 0x0F	; 15
 640:	73 e0       	ldi	r23, 0x03	; 3
 642:	85 e0       	ldi	r24, 0x05	; 5
 644:	81 dd       	rcall	.-1278   	; 0x148 <new>
	new(4, t0, true);
 646:	41 e0       	ldi	r20, 0x01	; 1
 648:	6f e0       	ldi	r22, 0x0F	; 15
 64a:	73 e0       	ldi	r23, 0x03	; 3
 64c:	84 e0       	ldi	r24, 0x04	; 4
 64e:	7c dd       	rcall	.-1288   	; 0x148 <new>
	new(3, t0, true);
 650:	41 e0       	ldi	r20, 0x01	; 1
 652:	6f e0       	ldi	r22, 0x0F	; 15
 654:	73 e0       	ldi	r23, 0x03	; 3
 656:	83 e0       	ldi	r24, 0x03	; 3
 658:	77 dd       	rcall	.-1298   	; 0x148 <new>
	new(2, t0, true);
 65a:	41 e0       	ldi	r20, 0x01	; 1
 65c:	6f e0       	ldi	r22, 0x0F	; 15
 65e:	73 e0       	ldi	r23, 0x03	; 3
 660:	82 e0       	ldi	r24, 0x02	; 2
 662:	72 dd       	rcall	.-1308   	; 0x148 <new>
	new(1, t0, true);
 664:	41 e0       	ldi	r20, 0x01	; 1
 666:	6f e0       	ldi	r22, 0x0F	; 15
 668:	73 e0       	ldi	r23, 0x03	; 3
 66a:	81 e0       	ldi	r24, 0x01	; 1
 66c:	6d dd       	rcall	.-1318   	; 0x148 <new>
	new(0, t0, true);
 66e:	41 e0       	ldi	r20, 0x01	; 1
 670:	6f e0       	ldi	r22, 0x0F	; 15
 672:	73 e0       	ldi	r23, 0x03	; 3
 674:	80 e0       	ldi	r24, 0x00	; 0
 676:	68 dd       	rcall	.-1328   	; 0x148 <new>
 678:	80 e0       	ldi	r24, 0x00	; 0
}
 67a:	90 e0       	ldi	r25, 0x00	; 0
 67c:	08 95       	ret

0000067e <init_serial>:
void init_serial()
{
	switch (N_SERIAL_PORTS)
	{
		case 4:
			kernel_data.serial_ctrl.queue_put_head[3] = kernel_data.serial_ctrl.serial_put_queue3;
 67e:	88 e3       	ldi	r24, 0x38	; 56
 680:	97 e0       	ldi	r25, 0x07	; 7
 682:	90 93 5f 06 	sts	0x065F, r25	; 0x80065f <_edata+0x45f>
 686:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <_edata+0x45e>
			kernel_data.serial_ctrl.queue_put_tail[3] = kernel_data.serial_ctrl.serial_put_queue3 + 1;
 68a:	89 e3       	ldi	r24, 0x39	; 57
 68c:	97 e0       	ldi	r25, 0x07	; 7
 68e:	90 93 67 06 	sts	0x0667, r25	; 0x800667 <_edata+0x467>
 692:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <_edata+0x466>
			kernel_data.serial_ctrl.queue_get_head[3] = kernel_data.serial_ctrl.serial_get_queue3;
 696:	88 e5       	ldi	r24, 0x58	; 88
 698:	97 e0       	ldi	r25, 0x07	; 7
 69a:	90 93 6f 06 	sts	0x066F, r25	; 0x80066f <_edata+0x46f>
 69e:	80 93 6e 06 	sts	0x066E, r24	; 0x80066e <_edata+0x46e>
			kernel_data.serial_ctrl.queue_get_tail[3] = kernel_data.serial_ctrl.serial_get_queue3 + 1;
 6a2:	89 e5       	ldi	r24, 0x59	; 89
 6a4:	97 e0       	ldi	r25, 0x07	; 7
 6a6:	90 93 77 06 	sts	0x0677, r25	; 0x800677 <_edata+0x477>
 6aa:	80 93 76 06 	sts	0x0676, r24	; 0x800676 <_edata+0x476>
		case 3:
			kernel_data.serial_ctrl.queue_put_head[2] = kernel_data.serial_ctrl.serial_put_queue2;
 6ae:	88 ef       	ldi	r24, 0xF8	; 248
 6b0:	96 e0       	ldi	r25, 0x06	; 6
 6b2:	90 93 5d 06 	sts	0x065D, r25	; 0x80065d <_edata+0x45d>
 6b6:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <_edata+0x45c>
			kernel_data.serial_ctrl.queue_put_tail[2] = kernel_data.serial_ctrl.serial_put_queue2 + 1;
 6ba:	89 ef       	ldi	r24, 0xF9	; 249
 6bc:	96 e0       	ldi	r25, 0x06	; 6
 6be:	90 93 65 06 	sts	0x0665, r25	; 0x800665 <_edata+0x465>
 6c2:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <_edata+0x464>
			kernel_data.serial_ctrl.queue_get_head[2] = kernel_data.serial_ctrl.serial_get_queue2;
 6c6:	88 e1       	ldi	r24, 0x18	; 24
 6c8:	97 e0       	ldi	r25, 0x07	; 7
 6ca:	90 93 6d 06 	sts	0x066D, r25	; 0x80066d <_edata+0x46d>
 6ce:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <_edata+0x46c>
			kernel_data.serial_ctrl.queue_get_tail[2] = kernel_data.serial_ctrl.serial_get_queue2 + 1;
 6d2:	89 e1       	ldi	r24, 0x19	; 25
 6d4:	97 e0       	ldi	r25, 0x07	; 7
 6d6:	90 93 75 06 	sts	0x0675, r25	; 0x800675 <_edata+0x475>
 6da:	80 93 74 06 	sts	0x0674, r24	; 0x800674 <_edata+0x474>
		case 2:
			kernel_data.serial_ctrl.queue_put_head[1] = kernel_data.serial_ctrl.serial_put_queue1;
 6de:	88 eb       	ldi	r24, 0xB8	; 184
 6e0:	96 e0       	ldi	r25, 0x06	; 6
 6e2:	90 93 5b 06 	sts	0x065B, r25	; 0x80065b <_edata+0x45b>
 6e6:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <_edata+0x45a>
			kernel_data.serial_ctrl.queue_put_tail[1] = kernel_data.serial_ctrl.serial_put_queue1 + 1;
 6ea:	89 eb       	ldi	r24, 0xB9	; 185
 6ec:	96 e0       	ldi	r25, 0x06	; 6
 6ee:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <_edata+0x463>
 6f2:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <_edata+0x462>
			kernel_data.serial_ctrl.queue_get_head[1] = kernel_data.serial_ctrl.serial_get_queue1;
 6f6:	88 ed       	ldi	r24, 0xD8	; 216
 6f8:	96 e0       	ldi	r25, 0x06	; 6
 6fa:	90 93 6b 06 	sts	0x066B, r25	; 0x80066b <_edata+0x46b>
 6fe:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <_edata+0x46a>
			kernel_data.serial_ctrl.queue_get_tail[1] = kernel_data.serial_ctrl.serial_get_queue1 + 1;
 702:	89 ed       	ldi	r24, 0xD9	; 217
 704:	96 e0       	ldi	r25, 0x06	; 6
 706:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <_edata+0x473>
 70a:	80 93 72 06 	sts	0x0672, r24	; 0x800672 <_edata+0x472>
		case 1:
			kernel_data.serial_ctrl.queue_put_head[0] = kernel_data.serial_ctrl.serial_put_queue0;
 70e:	88 e7       	ldi	r24, 0x78	; 120
 710:	96 e0       	ldi	r25, 0x06	; 6
 712:	90 93 59 06 	sts	0x0659, r25	; 0x800659 <_edata+0x459>
 716:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <_edata+0x458>
			kernel_data.serial_ctrl.queue_put_tail[0] = kernel_data.serial_ctrl.serial_put_queue0 + 1;
 71a:	89 e7       	ldi	r24, 0x79	; 121
 71c:	96 e0       	ldi	r25, 0x06	; 6
 71e:	90 93 61 06 	sts	0x0661, r25	; 0x800661 <_edata+0x461>
 722:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <_edata+0x460>
			kernel_data.serial_ctrl.queue_get_head[0] = kernel_data.serial_ctrl.serial_get_queue0;
 726:	88 e9       	ldi	r24, 0x98	; 152
 728:	96 e0       	ldi	r25, 0x06	; 6
 72a:	90 93 69 06 	sts	0x0669, r25	; 0x800669 <_edata+0x469>
 72e:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <_edata+0x468>
			kernel_data.serial_ctrl.queue_get_tail[0] = kernel_data.serial_ctrl.serial_get_queue0 + 1;
 732:	89 e9       	ldi	r24, 0x99	; 153
 734:	96 e0       	ldi	r25, 0x06	; 6
 736:	90 93 71 06 	sts	0x0671, r25	; 0x800671 <_edata+0x471>
 73a:	80 93 70 06 	sts	0x0670, r24	; 0x800670 <_edata+0x470>
	}
	
	PRR0 &= ~(0b1 << PRUSART0);
 73e:	e4 e6       	ldi	r30, 0x64	; 100
 740:	f0 e0       	ldi	r31, 0x00	; 0
 742:	80 81       	ld	r24, Z
 744:	8d 7f       	andi	r24, 0xFD	; 253
 746:	80 83       	st	Z, r24
	PRR1 &= ~((0b1 << PRUSART3) | (0b1 << PRUSART1) | (0b1 << PRUSART1));
 748:	e5 e6       	ldi	r30, 0x65	; 101
 74a:	f0 e0       	ldi	r31, 0x00	; 0
 74c:	80 81       	ld	r24, Z
 74e:	8a 7f       	andi	r24, 0xFA	; 250
 750:	80 83       	st	Z, r24
 752:	08 95       	ret

00000754 <_exit>:
 754:	f8 94       	cli

00000756 <__stop_program>:
 756:	ff cf       	rjmp	.-2      	; 0x756 <__stop_program>
